import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// paths
const ROOT = path.join(__dirname, "..");
const PHOTOS_DIR = path.join(ROOT, "public", "photos");
const OUT_FILE = path.join(ROOT, "lib", "photoIndex.generated.ts");

// We import your mapping by reading the compiled TS? Nope (node can’t import TS by default).
// So we keep a tiny JSON mirror to keep this simple OR we make this script write-time require via dynamic TS transpile.
// Simplest: store mapping in JSON used by generator, and re-export it in TS.

const CITY_JSON = path.join(ROOT, "lib", "cities.json");
if (!fs.existsSync(CITY_JSON)) {
    console.error(`Missing ${CITY_JSON}. Create it (same as CITY_BY_AIRPORT).`);
    process.exit(1);
}

const CITY_BY_AIRPORT = JSON.parse(fs.readFileSync(CITY_JSON, "utf8"));

// Helpers
const isImage = (f) => /\.(png|jpg|jpeg|webp|gif)$/i.test(f);

function parseMeta(filename) {
    // supports: 2024-01-02_caption words.jpg
    const base = filename.replace(/\.[^.]+$/, "");
    const m = base.match(/^(\d{4}-\d{2}-\d{2})_(.+)$/);
    if (!m) return { date: null, caption: base.replace(/[-_]/g, " ") };

    const date = m[1];
    const caption = m[2].replace(/[-_]/g, " ");
    return { date, caption };
}

function safeReadDir(dir) {
    try {
        return fs.readdirSync(dir, { withFileTypes: true });
    } catch {
        return [];
    }
}

function main() {
    // Ensure photos dir exists
    if (!fs.existsSync(PHOTOS_DIR)) {
        fs.mkdirSync(PHOTOS_DIR, { recursive: true });
    }

    const entries = safeReadDir(PHOTOS_DIR)
        .filter((d) => d.isDirectory())
        .map((d) => d.name);

    // Build city->files map
    const cityToPhotos = {};
    for (const cityFolder of entries) {
        const folderPath = path.join(PHOTOS_DIR, cityFolder);
        const files = safeReadDir(folderPath)
            .filter((f) => f.isFile() && isImage(f.name))
            .map((f) => f.name);

        cityToPhotos[cityFolder] = files.map((name) => {
            const meta = parseMeta(name);
            return {
                src: `/photos/${cityFolder}/${name}`,
                caption: meta.caption,
                date: meta.date,
            };
        });
    }

    // Build airport->photos using CITY_BY_AIRPORT
    const airportIndex = {};
    for (const [airport, city] of Object.entries(CITY_BY_AIRPORT)) {
        airportIndex[airport] = cityToPhotos[city] ?? [];
    }

    const file = `/* AUTO-GENERATED FILE — DO NOT EDIT
   * Generated by: scripts/generatePhotoIndex.mjs
   */

export type PhotoItem = { src: string; caption?: string; date?: string };

export const CITY_BY_AIRPORT: Record<string, string> = ${JSON.stringify(
        CITY_BY_AIRPORT,
        null,
        2
    )} as const;

export const PHOTO_INDEX: Record<string, PhotoItem[]> = ${JSON.stringify(
        airportIndex,
        null,
        2
    )};

export function getCityForAirport(code: string) {
  return CITY_BY_AIRPORT[code] ?? null;
}

export function getPhotosForAirport(code: string): PhotoItem[] {
  return PHOTO_INDEX[code] ?? [];
}
`;

    fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true });
    fs.writeFileSync(OUT_FILE, file, "utf8");
    console.log(`✅ Wrote ${path.relative(ROOT, OUT_FILE)}`);
}

main();